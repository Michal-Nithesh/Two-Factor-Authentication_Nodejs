import { JsonDBConfig } from './lib/JsonDBConfig';
export { Config, ConfigWithAdapter } from './lib/JsonDBConfig';
export { DatabaseError, DataError } from './lib/Errors';
export { IAdapter } from './adapter/IAdapter';
export { JsonAdapter } from './adapter/data/JsonAdapter';
export { FileAdapter } from './adapter/file/FileAdapter';
export type FindCallback = (entry: any, index: number | string) => boolean;
export declare class JsonDB {
    private loaded;
    private data;
    private readonly config;
    /**
     * JSONDB Constructor
     * @param config Configuration for the database
     */
    constructor(config: JsonDBConfig);
    /**
     * Process datapath into different parts
     * @param dataPath
     */
    private processDataPath;
    private retrieveData;
    private getParentData;
    /**
     * Get the wanted data
     * @param dataPath path of the data to retrieve
     * @returns {Promise<any>}
     */
    getData(dataPath: string): Promise<any>;
    /**
     * Same as getData only here it's directly typed to your object
     * @param dataPath  path of the data to retrieve
     * @returns {Promise}
     */
    getObject<T>(dataPath: string): Promise<T>;
    /**
     * Same as getData but with your own object type and a possible default value when we can't find the data path
     * @param dataPath path of the data to retrieve
     * @param defaultValue value to use when the dataPath doesn't lead to data
     * @returns {Promise}
     * @throws {DataError}
     */
    getObjectDefault<T>(dataPath: string, defaultValue?: T): Promise<T>;
    /**
     * Check for existing datapath
     * @param dataPath
     * @returns {Promise<boolean>}
     */
    exists(dataPath: string): Promise<boolean>;
    /**
     * Returns the number of element which constitutes the array
     * @param dataPath
     * @returns {Promise<number>}
     * @throws {DataError}
     */
    count(dataPath: string): Promise<number>;
    /**
     * Returns the index of the object that meets the criteria submitted. Returns -1, if no match is found.
     * @param dataPath  base dataPath from where to start searching
     * @param searchValue value to look for in the dataPath
     * @param propertyName name of the property to look for searchValue
     * @returns {Promise<number>}
     */
    getIndex(dataPath: string, searchValue: string | number, propertyName?: string): Promise<number>;
    /**
     * Return the index of the value inside the array. Returns -1, if no match is found.
     * @param dataPath  base dataPath from where to start searching
     * @param searchValue value to look for in the dataPath
     * @returns {Promise<number>}
     */
    getIndexValue(dataPath: string, searchValue: string | number): Promise<number>;
    private getArrayData;
    /**
     * Find all specific entry in an array/object
     * @param rootPath base dataPath from where to start searching
     * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.
     * @returns {Promise}
     * @throws {DataError}
     */
    filter<T>(rootPath: string, callback: FindCallback): Promise<T[] | undefined>;
    /**
     * Find a specific entry in an array/object
     * @param rootPath base dataPath from where to start searching
     * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.
     * @returns {Promise}
     * @throws {DataError}
     */
    find<T>(rootPath: string, callback: FindCallback): Promise<T | undefined>;
    /**
     * Pushing data into the database
     * @param dataPath path leading to the data
     * @param data data to push
     * @param override overriding or not the data, if not, it will merge them
     * @returns {Promise<void>}
     * @throws {DataError}
     */
    push(dataPath: string, data: any, override?: boolean): Promise<void>;
    /**
     * Delete the data
     * @param dataPath path leading to the data
     */
    delete(dataPath: string): Promise<void>;
    /**
     * Only use this if you know what you're doing.
     * It reset the full data of the database.
     * @param data
     */
    resetData(data: any): void;
    /**
     * Reload the database from the file
     */
    reload(): Promise<void>;
    /**
     * Manually load the database
     * It is automatically called when the first getData is done
     * @return {Promise<void>}
     * @throws {DatabaseError}
     */
    load(): Promise<void>;
    /**
     * Manually save the database
     * By default you can't save the database if it's not loaded
     * @param force force the save of the database
     * @return {Promise<void>}
     * @throws {DatabaseError}
     */
    save(force?: boolean): Promise<void>;
    /**
     * Convert a router style path to a normal path
     * By default propertyName to search is "id"
     * @param path router based path to a correct base path
     * @param propertyName name of the property to look for searchValue
     */
    fromPath(path: string, propertyName?: string): Promise<string>;
}
